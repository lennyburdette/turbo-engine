# e2e.yml â€” Full end-to-end integration tests.
# Builds all Docker images, starts the platform via Docker Compose,
# runs smoke tests, captures traces, and uploads a CI report.
name: E2E

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: e2e-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  e2e:
    name: End-to-end integration tests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Build Docker images individually (matches working Build workflow)
      # -----------------------------------------------------------------------
      - name: Build Go service images
        run: |
          docker compose --progress=plain -f infra/docker/docker-compose.yml build registry
          docker compose --progress=plain -f infra/docker/docker-compose.yml build builder
          docker compose --progress=plain -f infra/docker/docker-compose.yml build operator
          docker compose --progress=plain -f infra/docker/docker-compose.yml build envmanager

      - name: Build gateway image
        run: docker compose --progress=plain -f infra/docker/docker-compose.yml build gateway

      - name: Build console image
        run: docker compose --progress=plain -f infra/docker/docker-compose.yml build console

      - name: Verify images
        run: |
          IMAGES=$(docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | head -15)
          echo "$IMAGES"
          echo "::warning title=Docker Images::${IMAGES//$'\n'/%0A}"
          COMPOSE_IMAGES=$(docker compose -f infra/docker/docker-compose.yml config --images 2>&1)
          echo "$COMPOSE_IMAGES"
          echo "::warning title=Compose Expected Images::${COMPOSE_IMAGES//$'\n'/%0A}"

      - name: Pull infra images
        run: docker compose -f infra/docker/docker-compose.yml pull --ignore-buildable

      - name: Start platform
        run: docker compose -f infra/docker/docker-compose.yml up -d --no-build

      - name: Wait for services to be healthy
        run: ./hack/scripts/wait-for-healthy.sh 180
        env:
          HEALTH_TIMEOUT: "180"

      # -----------------------------------------------------------------------
      # Diagnostics on failure (always capture container state)
      # -----------------------------------------------------------------------
      - name: Container diagnostics
        if: failure()
        run: |
          # Write diagnostics to file (uploaded as artifact) AND use annotations (readable via API)
          DIAG_FILE="${GITHUB_WORKSPACE}/ci-report/diagnostics.txt"
          mkdir -p "${GITHUB_WORKSPACE}/ci-report"

          echo "=== CONTAINER STATUS ===" | tee "$DIAG_FILE"
          docker compose -f infra/docker/docker-compose.yml ps -a 2>&1 | tee -a "$DIAG_FILE" || true
          echo "" | tee -a "$DIAG_FILE"

          echo "=== PORT CONNECTIVITY ===" | tee -a "$DIAG_FILE"
          for port in 8080 8081 8082 8083 8084 3000; do
            code=$(curl -s -o /dev/null -w '%{http_code}' "http://localhost:${port}/healthz" 2>/dev/null || echo "000")
            echo "  Port $port: HTTP $code" | tee -a "$DIAG_FILE"
          done
          echo "" | tee -a "$DIAG_FILE"

          echo "=== SERVICE LOGS ===" | tee -a "$DIAG_FILE"
          for svc in otel-collector registry builder operator envmanager gateway console; do
            echo "--- $svc ---" | tee -a "$DIAG_FILE"
            docker compose -f infra/docker/docker-compose.yml logs --tail=20 --no-color "$svc" 2>&1 | tee -a "$DIAG_FILE" || echo "(no logs)" | tee -a "$DIAG_FILE"
          done

          # Emit key diagnostics as annotations (accessible via API)
          CONTAINER_STATUS=$(docker compose -f infra/docker/docker-compose.yml ps -a 2>&1 | head -15 || true)
          echo "::warning title=Container Status::${CONTAINER_STATUS//$'\n'/%0A}"

          PORT_STATUS=""
          for port in 8080 8081 8082 8083 8084 3000; do
            code=$(curl -s -o /dev/null -w '%{http_code}' "http://localhost:${port}/healthz" 2>/dev/null || echo "000")
            PORT_STATUS="${PORT_STATUS}Port ${port}: HTTP ${code}%0A"
          done
          echo "::warning title=Port Connectivity::${PORT_STATUS}"

      # -----------------------------------------------------------------------
      # Run smoke tests
      # -----------------------------------------------------------------------
      - name: Run smoke tests
        id: smoke
        run: ./hack/scripts/run-smoke-tests.sh

      # -----------------------------------------------------------------------
      # Capture observability data (always, even if smoke tests fail)
      # -----------------------------------------------------------------------
      - name: Capture traces
        if: always()
        run: ./hack/scripts/capture-traces.sh
        env:
          LOOKBACK_MINUTES: "10"

      - name: Capture screenshots
        if: always()
        run: ./hack/scripts/capture-screenshots.sh

      # -----------------------------------------------------------------------
      # Generate the CI report
      # -----------------------------------------------------------------------
      - name: Generate CI report
        if: always()
        run: ./hack/scripts/dump-ci-report.sh

      - name: Print CI report
        if: always()
        run: cat ci-report/REPORT.md

      # -----------------------------------------------------------------------
      # Dump logs on failure for debugging
      # -----------------------------------------------------------------------
      - name: Dump service logs on failure
        if: failure()
        run: docker compose -f infra/docker/docker-compose.yml logs --no-color --tail=500

      # -----------------------------------------------------------------------
      # Upload artifacts
      # -----------------------------------------------------------------------
      - name: Upload CI report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-report
          path: ci-report/
          retention-days: 14

      # -----------------------------------------------------------------------
      # Post summary to step summary and PR comment
      # -----------------------------------------------------------------------
      - name: Build E2E summary
        id: summary
        if: always()
        run: |
          SUMMARY_FILE=$(mktemp)

          # Header with overall result
          if [ -f ci-report/smoke-results.json ]; then
            total=$(grep -o '"total":\s*[0-9]*' ci-report/smoke-results.json | grep -o '[0-9]*' || echo "?")
            passed=$(grep -o '"passed":\s*[0-9]*' ci-report/smoke-results.json | grep -o '[0-9]*' || echo "?")
            failed=$(grep -o '"failed":\s*[0-9]*' ci-report/smoke-results.json | grep -o '[0-9]*' || echo "?")

            if [ "$failed" = "0" ]; then
              echo "### âœ… E2E Smoke Tests: All ${total} passed" >> "$SUMMARY_FILE"
            else
              echo "### âŒ E2E Smoke Tests: ${failed} failed (${passed}/${total} passed)" >> "$SUMMARY_FILE"
            fi

            echo "" >> "$SUMMARY_FILE"
            echo "| Test | Status | Detail | Duration |" >> "$SUMMARY_FILE"
            echo "|------|--------|--------|----------|" >> "$SUMMARY_FILE"

            while IFS= read -r line; do
              name=$(echo "$line" | grep -o '"name":"[^"]*"' | cut -d'"' -f4)
              status=$(echo "$line" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
              detail=$(echo "$line" | grep -o '"detail":"[^"]*"' | cut -d'"' -f4)
              duration=$(echo "$line" | grep -o '"duration_ms":[0-9]*' | cut -d: -f2)
              if [ -n "$name" ]; then
                icon="âœ…"
                [ "$status" = "fail" ] && icon="âŒ"
                echo "| \`${name}\` | ${icon} ${status} | ${detail} | ${duration:-0}ms |" >> "$SUMMARY_FILE"
              fi
            done < <(grep -o '{[^}]*}' ci-report/smoke-results.json | grep '"name"')
          else
            echo "### âš ï¸ E2E Smoke Tests: No results" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "Smoke tests may not have run. Check the workflow logs for build or startup failures." >> "$SUMMARY_FILE"
          fi

          # Service health table
          if [ -f ci-report/REPORT.md ]; then
            echo "" >> "$SUMMARY_FILE"
            echo "<details>" >> "$SUMMARY_FILE"
            echo "<summary>Service health & trace summary</summary>" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            # Extract sections 1 (health) and 3 (traces) from REPORT.md
            sed -n '/## 1\. Service Health/,/^---$/p' ci-report/REPORT.md | head -n -1 >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            sed -n '/## 3\. Trace Summary/,/^---$/p' ci-report/REPORT.md | head -n -1 >> "$SUMMARY_FILE"
            echo "</details>" >> "$SUMMARY_FILE"
          fi

          echo "" >> "$SUMMARY_FILE"
          echo "ðŸ“¦ Full CI report available in the [**ci-report** artifact](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})." >> "$SUMMARY_FILE"

          # Write to step summary
          cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"

          # Save path for the PR comment step
          echo "file=${SUMMARY_FILE}" >> "$GITHUB_OUTPUT"

      - name: Comment on PR
        if: always() && github.event_name == 'pull_request'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          REPO: ${{ github.repository }}
        run: |
          SUMMARY_FILE="${{ steps.summary.outputs.file }}"
          if [ ! -f "$SUMMARY_FILE" ]; then
            echo "No summary file found, skipping PR comment"
            exit 0
          fi

          MARKER="<!-- turbo-engine-e2e-bot -->"

          # Build the comment body with a hidden marker for upsert
          {
            echo "$MARKER"
            cat "$SUMMARY_FILE"
            echo ""
            echo "---"
            echo "*Posted by the E2E workflow â€” [view run](${RUN_URL})*"
          } > /tmp/pr-comment-body.txt

          # Find existing bot comment (if any) and update it, otherwise create new
          EXISTING_COMMENT_ID=$(gh api \
            "repos/${REPO}/issues/${PR_NUMBER}/comments" \
            --paginate --jq ".[] | select(.body | startswith(\"${MARKER}\")) | .id" \
            | head -1 || true)

          if [ -n "$EXISTING_COMMENT_ID" ]; then
            gh api \
              "repos/${REPO}/issues/comments/${EXISTING_COMMENT_ID}" \
              -X PATCH -F body=@/tmp/pr-comment-body.txt
            echo "Updated existing comment ${EXISTING_COMMENT_ID}"
          else
            gh pr comment "$PR_NUMBER" --body-file /tmp/pr-comment-body.txt
            echo "Created new comment on PR #${PR_NUMBER}"
          fi

      # -----------------------------------------------------------------------
      # Teardown
      # -----------------------------------------------------------------------
      - name: Stop platform
        if: always()
        run: docker compose -f infra/docker/docker-compose.yml down -v
