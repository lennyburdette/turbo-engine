#!/usr/bin/env bash
# k8s-dump-report.sh — Generates ci-report/REPORT.md (top-level index) and
# captures Jaeger traces.  Per-scenario reports are generated by the scenario
# runner (k8s-run-scenario.py).
#
# Prerequisites: Run k8s-e2e-tests.sh and k8s-collect-debug.sh first.
#
# Output: ci-report/REPORT.md
set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
REPORT_DIR="${ROOT_DIR}/ci-report"
K8S_DIR="${REPORT_DIR}/k8s"
REPORT_FILE="${REPORT_DIR}/REPORT.md"

RESULTS_FILE="${REPORT_DIR}/k8s-e2e-results.json"
TIMELINE_FILE="${K8S_DIR}/timeline.txt"
TRACES_FILE="${REPORT_DIR}/traces.json"

JAEGER_PORT="${JAEGER_PORT:-16686}"

mkdir -p "${REPORT_DIR}" "${K8S_DIR}"

CYAN='\033[0;36m'
GREEN='\033[0;32m'
RESET='\033[0m'

info()  { printf "${CYAN}[INFO]${RESET}  %s\n" "$*" >&2; }
ok()    { printf "${GREEN}[OK]${RESET}    %s\n" "$*" >&2; }

# ---------------------------------------------------------------------------
# Capture traces from Jaeger (if port-forwarded)
# ---------------------------------------------------------------------------
info "Attempting to capture traces from Jaeger..."

JAEGER_URL="http://localhost:${JAEGER_PORT}"
jaeger_status=$(curl -s -o /dev/null -w '%{http_code}' "${JAEGER_URL}/" 2>/dev/null || echo "000")

if [[ "$jaeger_status" == "200" ]]; then
  NOW_US=$(( $(date +%s) * 1000000 ))
  START_US=$(( NOW_US - (10 * 60 * 1000000) ))

  {
    printf '{\n'
    printf '  "captured_at": "%s",\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    printf '  "services": {\n'

    first=true
    for svc in registry builder envmanager operator gateway orchestrator petstore-mock; do
      if ! $first; then printf ',\n'; fi
      first=false

      trace_data=$(curl -s "${JAEGER_URL}/api/traces?service=${svc}&start=${START_US}&end=${NOW_US}&limit=50&lookback=custom" 2>/dev/null || echo '{"data":[]}')
      printf '    "%s": %s' "$svc" "$trace_data"
    done

    printf '\n  }\n'
    printf '}\n'
  } > "${TRACES_FILE}"

  ok "Traces captured to traces.json"
else
  info "Jaeger not reachable (HTTP ${jaeger_status}) — skipping trace capture"
fi

# Generate trace viewer HTML + text summary.
TRACE_VIEWER="${SCRIPT_DIR}/generate-trace-viewer.sh"
if [[ -f "$TRACE_VIEWER" && -f "$TRACES_FILE" ]]; then
  info "Generating trace viewer..."
  bash "$TRACE_VIEWER" || true
fi

# Enrich scenario timeline reports with matching trace spans.
ENRICH_SCRIPT="${SCRIPT_DIR}/enrich-timeline-traces.py"
if [[ -f "$ENRICH_SCRIPT" && -f "$TRACES_FILE" ]]; then
  info "Enriching timeline reports with trace data..."
  python3 "$ENRICH_SCRIPT" "${REPORT_DIR}" || true
fi

# ---------------------------------------------------------------------------
# Build the top-level report
# ---------------------------------------------------------------------------
info "Generating report: ${REPORT_FILE}"

exec 3>&1
exec > "${REPORT_FILE}"

cat <<'HEADER'
# K8s E2E Report

HEADER

printf "**Generated:** %s\n\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

# --- Result banner --------------------------------------------------------
if [[ -f "$RESULTS_FILE" ]]; then
  total=$(grep -o '"total":\s*[0-9]*' "$RESULTS_FILE" | grep -o '[0-9]*' || echo "0")
  passed=$(grep -o '"passed":\s*[0-9]*' "$RESULTS_FILE" | grep -o '[0-9]*' || echo "0")
  failed=$(grep -o '"failed":\s*[0-9]*' "$RESULTS_FILE" | grep -o '[0-9]*' || echo "0")

  if [[ "$failed" == "0" ]]; then
    printf "**ALL %s TESTS PASSED**\n\n" "$total"
  else
    printf "**%s FAILED** (%s/%s passed)\n\n" "$failed" "$passed" "$total"
  fi
fi

# --- Timeline (compact) ---------------------------------------------------
if [[ -f "$TIMELINE_FILE" ]]; then
  printf '```\n'
  cat "$TIMELINE_FILE"
  printf '```\n\n'
fi

# --- Per-scenario summaries -----------------------------------------------
printf "## Scenarios\n\n"

# List scenario reports and link to them.
SCENARIO_DIR="${REPORT_DIR}/scenarios"
if [[ -d "$SCENARIO_DIR" ]]; then
  for scenario_report in "${SCENARIO_DIR}"/*/report.md; do
    [[ -f "$scenario_report" ]] || continue
    scenario_name=$(basename "$(dirname "$scenario_report")")

    # Extract the first line (the banner) for a quick summary.
    banner=$(head -1 "$scenario_report" | sed 's/^# //')

    # Count screenshots.
    ss_dir="${REPORT_DIR}/screenshots/${scenario_name}"
    ss_count=0
    if [[ -d "$ss_dir" ]]; then
      ss_count=$(find "$ss_dir" -name '*.png' 2>/dev/null | wc -l)
    fi

    printf "### [%s](./scenarios/%s/report.md)\n\n" "$banner" "$scenario_name"
    printf "%s screenshots" "$ss_count"
    if [[ -f "${REPORT_DIR}/traces.html" ]]; then
      printf " | [traces](./traces.html)"
    fi
    printf "\n\n"
  done
else
  echo "_No scenario reports found._"
  echo ""
fi

# --- Platform health (compact) --------------------------------------------
printf "## Platform Health\n\n"

if [[ -f "${K8S_DIR}/resources.txt" ]]; then
  # Extract just pod status lines (compact view).
  running=$(grep -c 'Running' "${K8S_DIR}/resources.txt" 2>/dev/null || echo "0")
  total_pods=$(grep -c '^pod/' "${K8S_DIR}/resources.txt" 2>/dev/null || echo "0")

  printf "**Pods:** %s/%s running\n\n" "$running" "$total_pods"

  # Show non-Running pods if any exist.
  non_running=$(grep '^pod/' "${K8S_DIR}/resources.txt" | grep -v 'Running' || true)
  if [[ -n "$non_running" ]]; then
    printf "**Non-running pods:**\n\`\`\`\n%s\n\`\`\`\n\n" "$non_running"
  fi

  printf "<details><summary>Full resource list</summary>\n\n"
  printf '```\n'
  cat "${K8S_DIR}/resources.txt"
  printf '```\n\n'
  printf "</details>\n\n"
fi

# --- Errors (only if found) -----------------------------------------------
SERVICES=(registry builder envmanager turbo-engine-operator gateway)
ERRORS_FOUND=false
ERROR_OUTPUT=""

for svc in "${SERVICES[@]}"; do
  LOG_FILE="${K8S_DIR}/logs-${svc}.txt"
  if [[ -f "$LOG_FILE" ]]; then
    errors=$(grep -iE '("level":"ERROR"|"level":"error"|panic|fatal)' "$LOG_FILE" \
      | grep -v 'failed to initialise OTLP' \
      | grep -v 'failed to initialize tracer' \
      | tail -5 || true)

    if [[ -n "$errors" ]]; then
      ERRORS_FOUND=true
      ERROR_OUTPUT+="**${svc}:**"$'\n'
      ERROR_OUTPUT+='```'$'\n'"${errors}"$'\n''```'$'\n\n'
    fi
  fi
done

if $ERRORS_FOUND; then
  printf "## Errors\n\n"
  printf "%s" "$ERROR_OUTPUT"
fi

# --- Trace summary (compact) ---------------------------------------------
if [[ -f "$TRACES_FILE" ]]; then
  printf "## Traces\n\n"

  trace_summary=""
  for svc in registry builder envmanager operator gateway orchestrator petstore-mock; do
    count=$(python3 -c "
import json
data = json.load(open('${TRACES_FILE}'))
svc_data = data.get('services',{}).get('${svc}',{})
traces = svc_data.get('data',[])
print(len(traces))
" 2>/dev/null || echo "0")
    if [[ "$count" != "0" ]]; then
      trace_summary+="**${svc}:** ${count}  "
    fi
  done

  if [[ -n "$trace_summary" ]]; then
    printf "%s\n\n" "$trace_summary"
  fi

  if [[ -f "${REPORT_DIR}/traces.html" ]]; then
    printf "[Open trace viewer](./traces.html)\n\n"
  fi
fi

# --- Debug data links (collapsed) ----------------------------------------
printf "## Debug Data\n\n"

HAS_DEBUG=false
for item in "K8s events:${K8S_DIR}/events.txt" "Operator actions:${K8S_DIR}/operator-actions.json"; do
  label="${item%%:*}"
  fpath="${item#*:}"
  if [[ -f "$fpath" ]]; then
    HAS_DEBUG=true
    lines=$(wc -l < "$fpath" 2>/dev/null || echo "0")
    printf "<details><summary>%s (%s lines)</summary>\n\n" "$label" "$lines"
    printf '```\n'
    cat "$fpath"
    printf '```\n\n'
    printf "</details>\n\n"
  fi
done

# Service logs — collapsed, short.
for svc in "${SERVICES[@]}"; do
  LOG_FILE="${K8S_DIR}/logs-${svc}.txt"
  if [[ -f "$LOG_FILE" ]]; then
    HAS_DEBUG=true
    lines=$(wc -l < "$LOG_FILE" 2>/dev/null || echo "0")
    printf "<details><summary>%s logs (%s lines)</summary>\n\n" "$svc" "$lines"
    printf '```\n'
    tail -50 "$LOG_FILE"
    printf '```\n\n'
    printf "</details>\n\n"
  fi
done

if ! $HAS_DEBUG; then
  echo "_No debug data collected._"
  echo ""
fi

cat <<'EOF'
---

_End of report. Per-scenario details are in the linked scenario reports above._
EOF

exec >&3

ok "Report written to: ${REPORT_FILE}"
info "Size: $(wc -c < "${REPORT_FILE}") bytes"

# ---------------------------------------------------------------------------
# Generate self-contained HTML report (no Jekyll dependency)
# ---------------------------------------------------------------------------
HTML_FILE="${REPORT_DIR}/REPORT.html"
info "Generating HTML report: ${HTML_FILE}"

# Read the CSS from the Python script's constant (keep in sync).
read -r -d '' REPORT_CSS <<'CSSEOF' || true
:root {
  --bg: #fff; --fg: #24292e; --fg-muted: #586069;
  --border: #e1e4e8; --bg-code: #f6f8fa; --link: #0366d6;
  --pass: #22863a; --fail: #cb2431;
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #0d1117; --fg: #c9d1d9; --fg-muted: #8b949e;
    --border: #30363d; --bg-code: #161b22; --link: #58a6ff;
    --pass: #3fb950; --fail: #f85149;
  }
}
* { box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
               Arial, sans-serif;
  font-size: 15px; line-height: 1.5; color: var(--fg);
  background: var(--bg); margin: 0; padding: 16px;
  max-width: 100vw; overflow-x: hidden;
}
.container { max-width: 900px; margin: 0 auto; }
h1 { font-size: 1.5em; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
h2 { font-size: 1.25em; margin-top: 1.5em; }
h3 { font-size: 1.1em; }
a { color: var(--link); text-decoration: none; }
a:hover { text-decoration: underline; }
pre {
  background: var(--bg-code); border: 1px solid var(--border);
  border-radius: 6px; padding: 12px; overflow-x: auto;
  font-size: 13px; line-height: 1.4; max-width: 100%;
}
code {
  font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
  font-size: 0.9em;
}
p code, li code, td code {
  background: var(--bg-code); padding: 2px 6px; border-radius: 3px;
}
table {
  border-collapse: collapse; width: 100%; font-size: 14px;
  margin: 12px 0; overflow-x: auto; display: block;
}
th, td {
  border: 1px solid var(--border); padding: 6px 10px;
  text-align: left; white-space: nowrap;
}
th { background: var(--bg-code); font-weight: 600; }
details { margin: 8px 0; }
summary { cursor: pointer; font-weight: 600; }
hr { border: none; border-top: 1px solid var(--border); margin: 24px 0; }
.breadcrumb { font-size: 13px; color: var(--fg-muted); margin-bottom: 8px; }
.breadcrumb a { color: var(--fg-muted); }
.pass { color: var(--pass); font-weight: 600; }
.fail { color: var(--fail); font-weight: 600; }
img { max-width: 100%; height: auto; border: 1px solid var(--border); border-radius: 6px; margin: 8px 0; }
.log-line { border-bottom: 1px solid var(--border); padding: 3px 0; font-size: 13px; font-family: SFMono-Regular, Consolas, monospace; display: flex; flex-wrap: wrap; gap: 4px; align-items: baseline; }
.log-line:last-child { border-bottom: none; }
.log-time { color: var(--fg-muted); font-size: 11px; flex-shrink: 0; }
.log-level { font-size: 11px; font-weight: 600; padding: 0 4px; border-radius: 3px; flex-shrink: 0; }
.log-level-info { color: var(--pass); }
.log-level-warn { color: #b08800; }
.log-level-error { color: var(--fail); }
.log-level-debug { color: var(--fg-muted); }
.log-msg { font-weight: 500; }
.log-meta { color: var(--fg-muted); font-size: 12px; }
.log-meta-key { color: var(--fg-muted); }
.log-meta-val { color: var(--fg); }
.log-raw { font-size: 13px; font-family: SFMono-Regular, Consolas, monospace; white-space: pre-wrap; word-break: break-all; }
.log-container { background: var(--bg-code); border: 1px solid var(--border); border-radius: 6px; padding: 8px 12px; overflow-x: auto; max-width: 100%; }
CSSEOF

# Helper to HTML-escape text.
html_esc() { printf '%s' "$1" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g'; }

# Render log content as structured HTML (JSON logs get parsed, others stay raw).
render_logs_html() {
  local content="$1"
  python3 -c "
import json, sys
from html import escape as E

content = sys.stdin.read().strip()
lines = content.split('\n')

# Quick check: JSON?
has_json = False
for line in lines[:5]:
    s = line.strip()
    if s and s.startswith('{'):
        try:
            json.loads(s)
            has_json = True
            break
        except json.JSONDecodeError:
            pass

if not has_json:
    print(f'<pre><code>{E(content)}</code></pre>')
    sys.exit(0)

MSG_KEYS = {'msg', 'message'}
META_SKIP = {'time', 'ts', 'timestamp', 'level', 'lvl', 'msg', 'message'}

print('<div class=\"log-container\">')
for line in lines:
    s = line.strip()
    if not s:
        continue
    try:
        obj = json.loads(s)
        if not isinstance(obj, dict):
            raise ValueError
    except (json.JSONDecodeError, ValueError):
        print(f'<div class=\"log-raw\">{E(s)}</div>')
        continue

    parts = []
    ts = obj.get('time') or obj.get('ts') or obj.get('timestamp') or ''
    if ts:
        ts_str = str(ts)
        if 'T' in ts_str:
            ts_str = ts_str.split('T', 1)[1].rstrip('Z')
            if '.' in ts_str:
                base, frac = ts_str.split('.', 1)
                ts_str = f'{base}.{frac[:3]}'
        parts.append(f'<span class=\"log-time\">{E(ts_str)}</span>')

    level = str(obj.get('level') or obj.get('lvl') or '').upper()
    if level:
        lcls = 'info'
        if level in ('WARN', 'WARNING'): lcls = 'warn'
        elif level in ('ERROR', 'ERR', 'FATAL', 'PANIC'): lcls = 'error'
        elif level in ('DEBUG', 'TRACE'): lcls = 'debug'
        parts.append(f'<span class=\"log-level log-level-{lcls}\">{E(level)}</span>')

    msg = ''
    for k in MSG_KEYS:
        if k in obj:
            msg = str(obj[k])
            break
    if msg:
        parts.append(f'<span class=\"log-msg\">{E(msg)}</span>')

    meta = []
    for k, v in obj.items():
        if k in META_SKIP: continue
        sv = str(v) if not isinstance(v, str) else v
        if len(sv) > 80: sv = sv[:77] + '...'
        meta.append(f'<span class=\"log-meta-key\">{E(k)}</span>=<span class=\"log-meta-val\">{E(sv)}</span>')
    if meta:
        parts.append('<span class=\"log-meta\">' + ' '.join(meta) + '</span>')

    print('<div class=\"log-line\">' + ' '.join(parts) + '</div>')
print('</div>')
" <<< "$content"
}

{
  cat <<HTMLHEAD
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>K8s E2E Report</title>
  <style>${REPORT_CSS}</style>
</head>
<body>
<div class="container">
HTMLHEAD

  printf '<h1>K8s E2E Report</h1>\n'
  printf '<p><strong>Generated:</strong> %s</p>\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  # --- Result banner -------------------------------------------------------
  if [[ -f "$RESULTS_FILE" ]]; then
    total=$(grep -o '"total":\s*[0-9]*' "$RESULTS_FILE" | grep -o '[0-9]*' || echo "0")
    passed=$(grep -o '"passed":\s*[0-9]*' "$RESULTS_FILE" | grep -o '[0-9]*' || echo "0")
    failed=$(grep -o '"failed":\s*[0-9]*' "$RESULTS_FILE" | grep -o '[0-9]*' || echo "0")

    if [[ "$failed" == "0" ]]; then
      printf '<p><span class="pass"><strong>ALL %s TESTS PASSED</strong></span></p>\n' "$total"
    else
      printf '<p><span class="fail"><strong>%s FAILED</strong></span> (%s/%s passed)</p>\n' "$failed" "$passed" "$total"
    fi
  fi

  # --- Timeline ------------------------------------------------------------
  if [[ -f "$TIMELINE_FILE" ]]; then
    printf '<pre><code>'
    html_esc "$(cat "$TIMELINE_FILE")"
    printf '</code></pre>\n'
  fi

  # --- Per-scenario summaries ----------------------------------------------
  printf '<h2>Scenarios</h2>\n'

  SCENARIO_DIR="${REPORT_DIR}/scenarios"
  if [[ -d "$SCENARIO_DIR" ]]; then
    for scenario_report in "${SCENARIO_DIR}"/*/report.md; do
      [[ -f "$scenario_report" ]] || continue
      scenario_name=$(basename "$(dirname "$scenario_report")")

      banner=$(head -1 "$scenario_report" | sed 's/^# //')
      banner_esc=$(html_esc "$banner")

      ss_dir="${REPORT_DIR}/screenshots/${scenario_name}"
      ss_count=0
      if [[ -d "$ss_dir" ]]; then
        ss_count=$(find "$ss_dir" -name '*.png' 2>/dev/null | wc -l)
      fi

      printf '<h3><a href="./scenarios/%s/">%s</a></h3>\n' "$scenario_name" "$banner_esc"
      printf '<p>%s screenshots' "$ss_count"
      if [[ -f "${REPORT_DIR}/traces.html" ]]; then
        printf ' | <a href="./traces.html">traces</a>'
      fi
      timeline_json="${SCENARIO_DIR}/${scenario_name}/timeline.json"
      if [[ -f "$timeline_json" ]]; then
        tl_events=$(python3 -c "import json;d=json.load(open('${timeline_json}'));print(len(d.get('events',[])))" 2>/dev/null || echo "0")
        printf ' | %s timeline events' "$tl_events"
      fi
      printf '</p>\n'
    done
  else
    printf '<p><em>No scenario reports found.</em></p>\n'
  fi

  # --- Platform health -----------------------------------------------------
  printf '<h2>Platform Health</h2>\n'

  if [[ -f "${K8S_DIR}/resources.txt" ]]; then
    running=$(grep -c 'Running' "${K8S_DIR}/resources.txt" 2>/dev/null || echo "0")
    total_pods=$(grep -c '^pod/' "${K8S_DIR}/resources.txt" 2>/dev/null || echo "0")
    printf '<p><strong>Pods:</strong> %s/%s running</p>\n' "$running" "$total_pods"

    non_running=$(grep '^pod/' "${K8S_DIR}/resources.txt" | grep -v 'Running' || true)
    if [[ -n "$non_running" ]]; then
      printf '<p><strong>Non-running pods:</strong></p>\n<pre><code>'
      html_esc "$non_running"
      printf '</code></pre>\n'
    fi

    lines_count=$(wc -l < "${K8S_DIR}/resources.txt" 2>/dev/null || echo "0")
    printf '<details><summary>Full resource list (%s lines)</summary>\n<pre><code>' "$lines_count"
    html_esc "$(cat "${K8S_DIR}/resources.txt")"
    printf '</code></pre>\n</details>\n'
  fi

  # --- Errors --------------------------------------------------------------
  SERVICES_HTML=(registry builder envmanager turbo-engine-operator gateway)
  ERRORS_FOUND_HTML=false
  ERROR_BUF=""

  for svc in "${SERVICES_HTML[@]}"; do
    LOG_FILE="${K8S_DIR}/logs-${svc}.txt"
    if [[ -f "$LOG_FILE" ]]; then
      errors=$(grep -iE '("level":"ERROR"|"level":"error"|panic|fatal)' "$LOG_FILE" \
        | grep -v 'failed to initialise OTLP' \
        | grep -v 'failed to initialize tracer' \
        | tail -5 || true)
      if [[ -n "$errors" ]]; then
        ERRORS_FOUND_HTML=true
        ERROR_BUF+="<p><strong>$(html_esc "$svc"):</strong></p>"
        ERROR_BUF+="<pre><code>$(html_esc "$errors")</code></pre>"
      fi
    fi
  done

  if $ERRORS_FOUND_HTML; then
    printf '<h2>Errors</h2>\n%s\n' "$ERROR_BUF"
  fi

  # --- Traces --------------------------------------------------------------
  if [[ -f "$TRACES_FILE" ]]; then
    printf '<h2>Traces</h2>\n<p>'
    for svc in registry builder envmanager operator gateway orchestrator petstore-mock; do
      count=$(python3 -c "
import json
data = json.load(open('${TRACES_FILE}'))
svc_data = data.get('services',{}).get('${svc}',{})
print(len(svc_data.get('data',[])))
" 2>/dev/null || echo "0")
      if [[ "$count" != "0" ]]; then
        printf '<strong>%s:</strong> %s &nbsp; ' "$svc" "$count"
      fi
    done
    printf '</p>\n'
    if [[ -f "${REPORT_DIR}/traces.html" ]]; then
      printf '<p><a href="./traces.html">Open trace viewer</a></p>\n'
    fi
  fi

  # --- Debug data ----------------------------------------------------------
  printf '<h2>Debug Data</h2>\n'

  for item in "K8s events:${K8S_DIR}/events.txt" "Operator actions:${K8S_DIR}/operator-actions.json"; do
    label="${item%%:*}"
    fpath="${item#*:}"
    if [[ -f "$fpath" ]]; then
      lines_count=$(wc -l < "$fpath" 2>/dev/null || echo "0")
      printf '<details><summary>%s (%s lines)</summary>\n<pre><code>' "$(html_esc "$label")" "$lines_count"
      html_esc "$(cat "$fpath")"
      printf '</code></pre>\n</details>\n'
    fi
  done

  for svc in "${SERVICES_HTML[@]}"; do
    LOG_FILE="${K8S_DIR}/logs-${svc}.txt"
    if [[ -f "$LOG_FILE" ]]; then
      lines_count=$(wc -l < "$LOG_FILE" 2>/dev/null || echo "0")
      printf '<details><summary>%s logs (%s lines)</summary>\n' "$(html_esc "$svc")" "$lines_count"
      render_logs_html "$(tail -50 "$LOG_FILE")"
      printf '</details>\n'
    fi
  done

  printf '<hr>\n<p><em>End of report. Per-scenario details are in the linked scenario reports above.</em></p>\n'
  printf '</div>\n</body>\n</html>\n'
} > "${HTML_FILE}"

ok "HTML report written to: ${HTML_FILE}"
info "HTML size: $(wc -c < "${HTML_FILE}") bytes"
